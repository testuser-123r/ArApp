<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>AR Ball Schlag App</title>
    <!-- A-Frame Bibliothek -->
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <!-- AR.js für A-Frame -->
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.3.2/aframe/build/aframe-ar.js"></script>
    <!-- TensorFlow.js und Handpose Modell -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.20.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>
    <!-- Drei.js für zusätzliche 3D-Funktionen -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; height: 100%; width: 100%; }
        #videoElement {
            display: none; /* Video-Element verstecken */
        }
    </style>
</head>
<body>
    <!-- Video-Element für die Handerkennung (verborgen) -->
    <video id="videoElement" autoplay playsinline></video>

    <a-scene embedded arjs='sourceType: webcam;' vr-mode-ui="enabled: false" renderer="logarithmicDepthBuffer: true;">
        <!-- Marker -->
        <a-marker preset="hiro">
            <!-- Fallender Ball -->
            <a-sphere id="ball" position="0 1 0" radius="0.1" color="red"></a-sphere>
        </a-marker>
        <!-- Kamera -->
        <a-entity camera></a-entity>
    </a-scene>

    <script>
        // Initialisierung von Handpose
        let model;
        const video = document.getElementById('videoElement');

        // Zugriff auf die Webcam
        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
            .then(stream => {
                video.srcObject = stream;
                video.play();
                // Nach dem Laden des Videos Modell laden
                video.onloadeddata = () => {
                    loadHandposeModel();
                };
            })
            .catch(err => {
                console.error("Fehler beim Zugriff auf die Webcam: ", err);
            });

        // Laden des Handpose-Modells
        async function loadHandposeModel() {
            model = await handpose.load();
            console.log("Handpose Modell geladen");
            detectHands();
        }

        // Funktion zur Handerkennung
        async function detectHands() {
            const scene = document.querySelector('a-scene');
            const camera = document.querySelector('[camera]').getObject3D('camera');
            const ball = document.getElementById('ball');

            async function frameLandmarks() {
                const predictions = await model.estimateHands(video, true);

                if (predictions.length > 0) {
                    const hand = predictions[0];
                    const indexFinger = hand.landmarks[8]; // Spitze des Zeigefingers

                    // Transformation der Handposition in A-Frame Koordinaten
                    const normalizedX = (indexFinger[0] / video.videoWidth) * 2 - 1;
                    const normalizedY = -(indexFinger[1] / video.videoHeight) * 2 + 1;
                    const vector = new THREE.Vector3(normalizedX, normalizedY, 0.5);
                    vector.unproject(camera);

                    const dir = vector.sub(camera.position).normalize();
                    const distance = -camera.position.z / dir.z;
                    const pos = camera.position.clone().add(dir.multiplyScalar(distance));

                    // Prüfen, ob die Hand den Ball berührt
                    const ballPos = new THREE.Vector3();
                    ball.object3D.getWorldPosition(ballPos);

                    const distanceToBall = pos.distanceTo(ballPos);
                    // Schwellenwert anpassen je nach Größe des Balls und Handerkennung
                    if (distanceToBall < 0.2) {
                        console.log("Ball getroffen!");
                        // Ball nach oben schießen
                        ball.setAttribute('position', `${ballPos.x} ${ballPos.y + 0.5} ${ballPos.z}`);
                    }
                }

                requestAnimationFrame(frameLandmarks);
            }

            frameLandmarks();
        }

        // Einfaches Physik-Setup für den Ball
        AFRAME.registerComponent('falling-ball', {
            schema: {
                velocity: { type: 'vec3', default: {x: 0, y: -0.01, z: 0} }
            },
            tick: function (time, timeDelta) {
                let velocity = this.data.velocity;
                let position = this.el.getAttribute('position');

                // Einfache Schwerkraft
                velocity.y -= 0.0001 * timeDelta;

                // Aktualisieren der Position
                position.x += velocity.x * timeDelta / 1000;
                position.y += velocity.y * timeDelta / 1000;
                position.z += velocity.z * timeDelta / 1000;

                // Bodenprüfung (y = 0)
                if (position.y < 0.1) { // y=0.1 als Bodenhöhe anpassen
                    position.y = 0.1;
                    velocity.y = 0;
                }

                this.data.velocity = velocity;
                this.el.setAttribute('position', position);
            }
        });

        // Ball-Komponente hinzufügen
        document.addEventListener('DOMContentLoaded', () => {
            const ball = document.getElementById('ball');
            ball.setAttribute('falling-ball', '');
        });
    </script>
</body>
</html>
